/*
 * %%
 * Copyright (C) 2012 University of Mannheim - Chair of Software Engineering
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the 
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public 
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/gpl-3.0.html>.
 * 
 */

package de.uma.dcsim.hardware;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.List;

import de.uma.dcsim.drEventHandling.DREventHandler;
import de.uma.dcsim.drEventHandling.SimpleDREventHandler;
import de.uma.dcsim.energyPriceModels.EnergyPriceModelSelector;
import de.uma.dcsim.eventHandling.Event;
import de.uma.dcsim.eventHandling.EventHandler;
import de.uma.dcsim.eventHandling.EventQueue;
import de.uma.dcsim.eventHandling.EventType;
import de.uma.dcsim.eventHandling.JobEvent;
import de.uma.dcsim.eventHandling.ServerEvent;
import de.uma.dcsim.powerModels.itPowerModels.ITPowerModelSelector;
import de.uma.dcsim.pueModels.PUEModelSelector;
import de.uma.dcsim.scheduling.Scheduler;
import de.uma.dcsim.scheduling.schedulingStrategies.SchedulingStrategyProvider;
import de.uma.dcsim.scheduling.schedulingStrategies.demandFlexStrategies.DemandFlexibilitySchedulingStrategy;
import de.uma.dcsim.simulationControl.Setup;
import de.uma.dcsim.utilities.BatchJob;
import de.uma.dcsim.utilities.ReserveProvisionType;
import de.uma.dcsim.utilities.ServerStatus;

/**
 * @author University of Mannheim
 *
 */
public class DC {
	
	//OLD ELEMENTS
	private boolean changed;
	
	//SCHEDULING STRATEGIES
	/**
	 * Scheduling strategy that is used to schedule DR events.
	 */
	private DemandFlexibilitySchedulingStrategy schedulingStrategy = SchedulingStrategyProvider.getSchedulingStrategy();

	//CONFIGURATION PARAMETERS
	/**
	 * Static PUE of the DC (not used as now a dynamic PUE trace is used).
	 */
	private double pue;
	
	/**
	 * Simulation time.
	 */
	private int clock;
	
	/**
	 * Name of the DC.
	 */
	private String name;
	
	/**
	 * Unique ID of the DC:
	 */
	private int id;
	
	/**
	 * Start date of the simulation.
	 */
	private Calendar simStartTime;
	
	/**
	 * Indicates whether this instance was generated by the deepCopy()-method of another DC instance.
	 */
	private boolean isCopy;
	
	//POWER CONSUMPTION MONITORING
	/**
	 * Current utilization off all servers in the DC.
	 */
	private double overallCurrentServerUtil;
	
	/**
	 * Total facility power consumption  of the DC:
	 */
	private int overallCurrentPC;
	
	/**
	 * Current HVAC system power consumption .
	 */
	private double currentHVACPower;
	
	/**
	 * List of total facility power consumption  at past points in simulation time.
	 */
	private ArrayList<Double> historicOverallPC;
	
	/**
	 * Indicates the point in simulation time at which this DC instance was created. Used to calculate energy costs.
	 */
	private int historicOverallECOffset;
	
	/**
	 * Current power consumption  off all occupied servers.
	 */
	private double occupiedServerPC;
	
	/**
	 * Current utilization of all occupied servers.
	 */
	private double occupiedServerUtil;
	
	/**
	 * Energy costs that come from the current point in simulation time.
	 */
	private double currentEnergyCost;
	
	/**
	 * Current IT power consumption  of the DC:
	 */
	private double currentITPower;
	
	//HARDWARE
	/**
	 * List of all servers in the DC.
	 */
	private List<Server> server;
	
	/**
	 * HVAC system of the DC:
	 */
	private HVAC hvac;
	
	/**
	 * List of all ESF devices of the DC.
	 */
	private List<ESF> ups;
	
	//SCHEDULING AND EVENT HANDLING
	/**
	 * EventHanlder component of the DC.
	 */
	private EventHandler eventHandler;
	
	/**
	 * EventQueue of the DC:
	 */
	private EventQueue eventQueue;
	
	/**
	 * Scheduler component of the DC.
	 */
	private Scheduler scheduler;
	
	/**
	 * DREventHandler component of the DC.
	 */
	private DREventHandler drEventHandler;
	
	/**
	 * Length of the scheduling interval in simulation time.
	 */
	private int schedulingInterval;
	
	/**
	 * Point in simulation time at which the next call of the scheduler component is supposed to happen.
	 */
	private int nextSchedulerCall;
	
	//BATCH WORKLOAD
	/**
	 * List of all jobs that were parsed from the workload trace, but are not yet submitted to the scheduler component.
	 */
	private ArrayList<BatchJob> unsubmittedParsedJobs;
	
	/**
	 * List of all jobs that are already finished.
	 */
	private ArrayList<BatchJob> finishedJobs;	


	private int copiedIndexOffset;
	
	//the following attributes only exist for copied DCs
	/**
	 * If this instance is a copy, this indicates the DC instance from which this instance was copied.
	 */
	private DC parent;
	
	/**
	 * Indicates the latest submission time of all unsubmitted jobs that were copied to this copied instance.
	 */
	private int lastUnsubmittedJobRequestDate;
	
	/**
	 * Indicates to which index in the unsubmittedParsedJobs list, a DC instance has copied the jobs from the original instance.
	 * Therefore, only exists and is used for copied instances.
	 */
	private int lastCopiedIndex;
	
	/**
	 * Indicates the value of the copiedIndexOffset that the parent instance of this instance had at the point of creation of this instance.
	 */
	private int copiedIndexOffsetAtCreation;
	

	public DC(double pue, String name, int id, List<Server> server, ArrayList<BatchJob> jobs, HVAC hvac, List<ESF> ups
			, Calendar simStartTime, int schedulingInterval) {
		this.pue = pue;
		this.setName(name);
		this.setId(id);
		this.server = server;
		this.unsubmittedParsedJobs = jobs;
		this.hvac = hvac;
		this.ups = ups;
		this.clock = 0;
		this.eventHandler = new EventHandler(this);
		this.scheduler = new Scheduler(this.schedulingStrategy, this);
		this.simStartTime = simStartTime;
		this.schedulingInterval = schedulingInterval;
		this.drEventHandler = new SimpleDREventHandler(this.scheduler, this);
		this.nextSchedulerCall = 0;
		this.isCopy = false;
		this.occupiedServerPC = 0;
		this.occupiedServerUtil = 0;
		this.copiedIndexOffset = 0;
		this.historicOverallECOffset = 1;
		this.currentEnergyCost = 0;

		
		this.finishedJobs = new ArrayList<BatchJob>();
		this.finishedJobs = this.eventHandler.getFinishedJobs();
		this.historicOverallPC = new ArrayList<Double>();
		
		this.eventQueue = new EventQueue(jobs);
		
	}

	/**
	 * Provides a deep copy of this DC instance.
	 * @param lastSubmissionDateOfCopiedUnsubmittedJobs Point in simulation time that indicates to which submission time, the jobs from the original DC instance are copied to the newly created
	 * instance.
	 * @return Deep copy object of this DC object.
	 */
	public DC deepCopy(int lastSubmissionDateOfCopiedUnsubmittedJobs) {
		//Create new DC instance
		DC copy = new DC(this.pue, this.name, this.id, new ArrayList<Server>(), new ArrayList<BatchJob>(),
				hvac.deepCopy(), new ArrayList<ESF>(), (Calendar) simStartTime.clone(),
				schedulingInterval);
		
		//Set clock of copy
		copy.setClock(this.clock);
		
		//Set offsets and last submission date up to which unsubmitted jobs are copied
		if(!this.isCopy) {
			copy.setIsCopy(this, lastSubmissionDateOfCopiedUnsubmittedJobs, this.copiedIndexOffset);
		}
		else {
			copy.setIsCopy(this, lastSubmissionDateOfCopiedUnsubmittedJobs, this.copiedIndexOffsetAtCreation);
		}
		
		//Set next scheduler call timestep in the copy
		copy.setNextSchedulerCall(this.nextSchedulerCall);
		
		//Set power consumption of the occupied servers and set overall PC offset
		copy.setOccupiedServerPC(this.occupiedServerPC);
		copy.setHistoricOverallPCOffset(this.clock-1);

		//Copy all ESF devices
		for (ESF esf : ups) {
			copy.addESF(esf.deepCopy());
		}
		
		//Copy the batch workload
		ArrayList<BatchJob> jobs = new ArrayList<BatchJob>();
		ArrayList<BatchJob> submittedJobs = new ArrayList<BatchJob>();
		ArrayList<BatchJob> affectedSubmittedJobs = new ArrayList<BatchJob>();
		ArrayList<BatchJob> scheduledJobs = new ArrayList<BatchJob>();
		ArrayList<BatchJob> runningJobs = new ArrayList<BatchJob>();
		ArrayList<BatchJob> pausedJobs = new ArrayList<BatchJob>();
		HashMap<String, BatchJob> jobIDInstanceMapping = new HashMap<String, BatchJob>();
		
		BatchJob job;
		for(int i=0; i < this.unsubmittedParsedJobs.size(); i++) {
			job = this.unsubmittedParsedJobs.get(i);
			if(job.getSubmissionTime() <= lastSubmissionDateOfCopiedUnsubmittedJobs) {
				jobs.add(job);
			}
			else {
				break;
			}
		}
		if(this.isCopy && this.lastUnsubmittedJobRequestDate < lastSubmissionDateOfCopiedUnsubmittedJobs) {
			jobs.addAll(this.requestAdditionalUnsubmittedJobs(lastSubmissionDateOfCopiedUnsubmittedJobs, this.lastCopiedIndex, this.copiedIndexOffsetAtCreation));
		}
		if(!this.isCopy) {
			copy.setLastCopiedIndex(jobs.size()-1);
		}
		else {
			copy.setLastCopiedIndex(this.lastCopiedIndex - (this.unsubmittedParsedJobs.size() - (jobs.size())));
		}
		
		jobs.addAll(this.scheduler.getSubmittedJobs());
		jobs.addAll(this.scheduler.getScheduledJobs());
		jobs.addAll(this.eventHandler.getPausedJobs());
		jobs.addAll(this.eventHandler.getRunningJobs());
		
		BatchJob c;
		for (int i=0; i < jobs.size(); i++) {
			job = jobs.get(i);
			c = job.deepCopy();

			switch(job.getStatus()) {
			case PARSED:
				copy.addUnsubmittedParsedJob(c);
				copy.scheduleEvent(new JobEvent(EventType.JOB_SUBMISSION, c.getSubmissionTime(), c));
				break;
			case FINISHED:
				break;
			case PAUSED:
				pausedJobs.add(c);
				break;
			case SUBMITTED:
				submittedJobs.add(c);
				break;
			case RUNNING:
				if(c.isRequestedToPause()) {
					copy.scheduleEvent(new JobEvent(EventType.JOB_PAUSE, this.clock, c));
				}
				else {
					copy.rescheduleEvent(c.getFinishEvent(), c.getCalculatedFinishTime());
				}
				runningJobs.add(c);
				break;
			case SCHEDULED:
//				System.out.println(c.getId());
				scheduledJobs.add(c);
				copy.rescheduleEvent(c.getStartEvent(), c.getStartTime());
				break;
			case RESCHEDULED:
				scheduledJobs.add(c);
				copy.rescheduleEvent(c.getRestartEvent(), c.getScheduledRestartTime());
				break;
			default:
				break;
			}
			jobIDInstanceMapping.put(c.getId(), c);
		}

		for(BatchJob j : this.scheduler.getAffectedSubmittedJobs()) {
			c = j.deepCopy();
			affectedSubmittedJobs.add(c);
		}
		
		//Copy all servers
		for (Server s : server) {
			copy.addServer(s.deepCopy());
		}

		copy.setSubmittedJobs(submittedJobs);
		copy.setScheduledJobs(scheduledJobs);
		copy.setAffectedSubmittedJobs(affectedSubmittedJobs);
		
		//Copy the current configuration of the demand flexibility scheduling strategy
		SimpleDREventHandler copyEventHandler = ((SimpleDREventHandler)copy.getDREventHandler());
		copyEventHandler.setShiftingFraction(this.schedulingStrategy.getShiftingPowerFraction());
		copyEventHandler.setScalingFrequency(this.schedulingStrategy.getScalingFrequency());
		
		//Copy the current resource allocation of the DC
		HashMap<Integer, String> serverJobMapping = this.eventHandler.getServerJobMapping();
		HashMap<Integer, String> newServerJobMapping = new HashMap<Integer, String>();
		for(int key : serverJobMapping.keySet()) {
			newServerJobMapping.put(key, serverJobMapping.get(key));
		}
		copy.setServerJobMapping(newServerJobMapping);
		copy.setPausedJobs(pausedJobs);
		copy.setRunningJobs(runningJobs);
		
		copy.initEventHandlerLists();
		
		List<Server> copiedOccupiedServer = copy.getOccupiedServer();
		List<BatchJob> copiedRunningJobs = copy.getRunningJobs();
		
		HashMap<String, ArrayList<Server>> assignedServerLists = new HashMap<String, ArrayList<Server>>();
		ArrayList<Server> cList;
		for(Server cs : copiedOccupiedServer) {
			cs.setCurrentJob(jobIDInstanceMapping.get(newServerJobMapping.get(cs.getId())));
			cs.update();
			
			cList = assignedServerLists.get(cs.getCurrentJob().getId());
			if(cList == null) {
				cList = new ArrayList<Server>();
				cList.add(cs);
				assignedServerLists.put(cs.getCurrentJob().getId(), cList);
			}
			else {
				cList.add(cs);
			}
		}
		
		for(BatchJob j : copiedRunningJobs) {
			j.assignServers(assignedServerLists.get(j.getId()));
		}
		
		//Update power consumption of the copy
		copy.updateJobAllocation(false, false);
		
		return copy;
	}
	
	/**
	 * Schedules the jobs for the upcoming scheduling interval.
	 * Thereby, the method checks whether the current value of the clock variable of the DC equals the value of the 
	 * nextSchedulerCall variable of the DC.
	 * When this is not the case, the scheduler component of the DC is not called.
	 */
	public void scheduleJobs() {
		if(this.getJobSubmissionEvents(this.clock) != null) {
			this.eventHandler.handleJobSubmissionEvents(this.clock);
		}
		
		//if call of scheduler is necessary
		if(this.clock == this.nextSchedulerCall) {
			this.nextSchedulerCall = this.nextSchedulerCall + this.schedulingInterval;
			
			if(this.isCopy) {
				//if this copy has to request additional jobs from the original DC in order to perform a proper simulation
				if(this.lastUnsubmittedJobRequestDate <= this.getEndOfNextSchedulingInterval()) {
					this.addAdditionalUnsubmittedJobs(this.getEndOfNextSchedulingInterval());
				}				
			}
			scheduler.scheduleNextInterval(0, ReserveProvisionType.NEGATIVE, schedulingInterval);
		}
	}
	
	/**
	 * Updates the allocation of the jobs to the servers in the DC.
	 * @param updateRemainingJobTimes Indicates whether one timesteps of simulation time should be elapsed for the relevant jobs.
	 * @param increaseClock Indicates whether the clock of the DC should be increased during the call of the method.
	 */
	public void updateJobAllocation(boolean updateRemainingJobTimes, boolean increaseClock) {
		//If this is false, it is used for a setup action, thus the occupied server power consumption is recalculated
		if(!updateRemainingJobTimes) {
			this.occupiedServerPC = 0;
			for(Server s : this.server) {
				s.update();
				if(s.getStatus() == ServerStatus.OCCUPIED) {
					this.occupiedServerPC += s.getCurrentPC();
				}
			}
		}
		
		// --ALLOCATOR UPDATE--
		//If the clock is supposed to be increased, the events for the current value of clock have to be handled
		if(increaseClock) {
			eventHandler.update(this.scheduler.getScheduledJobs(), this.clock, updateRemainingJobTimes);
		}

		// --SERVER EC--
		//Handle server update events
		if (server.size() != 0) {
			this.overallCurrentServerUtil = 0;

			if (this.eventQueue.getEvents(EventType.SERVER_UPDATE, this.clock) != null) {
				Server cServer;
				double oEC;
				double oUtil;
				for (Event event : this.eventQueue.getEvents(EventType.SERVER_UPDATE, this.clock)) {
					cServer = ((ServerEvent) event).getAffectedServer();

					oEC = cServer.getCurrentPC();
					oUtil = cServer.getCurrentUtil();
					cServer.update();

					this.occupiedServerUtil += (cServer.getCurrentUtil() - oUtil);
					this.occupiedServerPC += (cServer.getCurrentPC() - oEC);

				}
				if(Math.abs(this.occupiedServerPC) < 0.1) {
					this.occupiedServerPC = 0;
				}
			}
			
			//Calculate current total facility power consumption
			this.overallCurrentPC = 0;
			double serverPower = (this.eventHandler.getIdleServer().size())*Server.IDLE_POWER;
			serverPower += this.occupiedServerPC;
			
			this.overallCurrentPC += ITPowerModelSelector.getITPower(serverPower, this.eventHandler.getRunningJobs().size(), this.eventHandler.getOccupiedServer().size());
			this.currentITPower = this.overallCurrentPC;

			this.overallCurrentServerUtil = ((double)this.eventHandler.getOccupiedServer().size()/(double)this.server.size());

		}

		// --HVAC EC--
		this.hvac.update(overallCurrentServerUtil, this.overallCurrentPC, PUEModelSelector.getPUE(this.clock));
		this.overallCurrentPC += hvac.getCurrentPC();
		this.currentHVACPower = hvac.getCurrentPC();
		
		double usedEnergy = ((double)this.overallCurrentPC/1000.0)/(3600.0/(double)Setup.secondsPerSimulationTimestep);
		this.currentEnergyCost = EnergyPriceModelSelector.getEnergyPriceInCentPerKWh(clock)*usedEnergy;
		
		//If the clock should be increased, increase the clock and store current total facility power consumption in the list of the historic power consumption values
		if(increaseClock) {
			clock++;
			this.historicOverallPC.add((double)this.overallCurrentPC);
		}
	}
	
	/**
	 * Schedules an interval of the specified length so that the maximum power demand is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMaximumPowerDemand(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMaximumPowerDemand(DRIntervalLength);
	}
	
	/**
	 * Schedules an interval of the specified length so that the minimum power demand is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMinimumPowerDemand(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMinimumPowerDemand(DRIntervalLength);
	}
	
	/**
	 * Schedules an interval of the specified length so that the maximum power demand, which can be achieved through workload shifting, is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMaximumPowerDemandShiftingOnly(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMaximumPowerDemandShiftingOnly(DRIntervalLength);
	}
	
	/**
	 * Schedules an interval of the specified length so that the maximum power demand, which can be achieved through frequency scaling, is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMaximumPowerDemandDVFSOnly(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMaximumPowerDemandDVFSOnly(DRIntervalLength);
	}
	
	/**
	 * Schedules an interval of the specified length so that the minimum power demand, which can be achieved through workload shifting, is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMinimumPowerDemandShiftingOnly(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMinimumPowerDemandShiftingOnly(DRIntervalLength);
	}
	
	/**
	 * Schedules an interval of the specified length so that the minimum power demand, which can be achieved through frequency scaling, is reached.
	 * @param DRIntervalLength Length of the interval to schedule.
	 */
	public void scheduleJobsForMinimumPowerDemandDVFSOnly(int DRIntervalLength) {
		this.scheduler.scheduleNextIntervalForMinimumPowerDemandDVFSOnly(DRIntervalLength);
	}
	
	/**
	 * Add a server instance to the DC.
	 * @param server Server that should be added.
	 * @return Indicates whether the server was added successfully.
	 */
	public boolean addServer(Server server) {
		try {
			this.server.add(server);
		} catch (Exception e) {
			return false;
		}
		return true;
	}

	/**
	 * Add ESF device to the DC.
	 * @param esf ESF device that should be added.
	 * @return True when the ESF device was added successfully, otherwise false.
	 */
	public boolean addESF(ESF esf) {
		try {
			this.ups.add(esf);
		} catch (Exception e) {
			return false;
		}
		return true;
	}

	/**
	 * Adds a job to the list of unsubmitted parsed jobs.
	 * @param job Job that should be added to the list.
	 * @return True when the jobs was added successfully, false otherwise.
	 */
	public boolean addUnsubmittedParsedJob(BatchJob job) {
		try {
			this.unsubmittedParsedJobs.add(job);
		} catch (Exception e) {
			e.printStackTrace();
			return false;
		}
		return true;
	}
	
	/**
	 * Submits a job from the list of unsubmitted parsed jobs to the submitted jobs list of the scheduler component of the DC.
	 * Thereby, the equals method of the Object class is used to identify the job in the list of unsubmitted parsed jobs.
	 * Thus, the instance that is passed as parameter has to be the same as the instance that is contained in the list of unsubmitted parsed jobs. 
	 * @param job Job that should be submitted to the scheduler component.
	 */
	public void submitParsedJob(BatchJob job) {
		this.unsubmittedParsedJobs.remove(job);
		this.scheduler.addSubmittedJob(job);
		this.copiedIndexOffset++;
	}
	
	/**
	 * Submits a job from the list of unsubmitted parsed jobs to the affected submitted jobs list of the scheduler component of the DC.
	 * Thereby, the equals method of the Object class is used to identify the job in the list of unsubmitted parsed jobs.
	 * Thus, the instance that is passed as parameter has to be the same as the instance that is contained in the list of unsubmitted parsed jobs. 
	 * @param job Job that should be submitted to the scheduler component.
	 */
	public void submitAffectedSubmittedJob(BatchJob job) {
		this.unsubmittedParsedJobs.remove(job);
		this.scheduler.addAffectedSubmittedJob(job);
		this.copiedIndexOffset++;
	}
	
	/**
	 * Recalculates the power consumption values of the DC.
	 */
	public void setupDC() {
		eventHandler.update(unsubmittedParsedJobs, 0, false);
	}
	
	/**
	 * Retrieves the DC costs (SLA and energy) within the specified interval.
	 * @param intervalStart Start date of the interval for which the costs should be calculated.
	 * @param intervalEnd End date of the interval for which the costs should be calculated.
	 * @return Total DC costs from the specified interval.
	 */
	public double getCostsInSpecifiedInterval(int intervalStart, int intervalEnd) {
		return this.calculateEnergyCosts(intervalStart, intervalEnd) + this.calculateSLACosts(intervalStart, intervalEnd);
	}
	
	/**
	 * Removes a timestep from the EventQueue of the DC.
	 * This should be used to avoid that the size of the EventQueue grows too large during long simulations.
	 */
	public void removeKey() {
		this.eventQueue.removeKey(this.getClock()-1);
	}
	
	/**
	 * Initializes the server lists in the EventHandler component of the DC.
	 */
	public void initEventHandlerLists() {
		this.eventHandler.initLists();
	}
	
	public ArrayList<BatchJob> getUnsubmittedParsedJobs() {
		return unsubmittedParsedJobs;
	}

	public void setUnsubmittedParsedJobs(ArrayList<BatchJob> jobs) {
		this.unsubmittedParsedJobs = jobs;
	}
	
	public ArrayList<BatchJob> getAffectedSubmittedJobs() {
		return this.scheduler.getAffectedSubmittedJobs();
	}
	
	public void setAffectedSubmittedJobs(ArrayList<BatchJob> affectedSubmittedJobs) {
		this.scheduler.setAffectedSubmittedJobs(affectedSubmittedJobs);
	}
	
	public void setPausedJobs(ArrayList<BatchJob> pausedJobs) {
		this.eventHandler.setPausedJobs(pausedJobs);
	}
	
	public ArrayList<BatchJob> getPausedJobs() {
		return this.eventHandler.getPausedJobs();
	}
	
	public void setRunningJobs(ArrayList<BatchJob> runningJobs) {
		this.eventHandler.setRunningJobs(runningJobs);
	}
	
	public ArrayList<BatchJob> getRunningJobs() {
		return this.eventHandler.getRunningJobs();
	}
	
	public void setScheduledJobs(ArrayList<BatchJob> scheduledJobs) {
		this.scheduler.setScheduledJobs(scheduledJobs);
	}
	
	public ArrayList<BatchJob> getScheduledJobs() {
		return this.scheduler.getScheduledJobs();
	}
	
	public void setSubmittedJobs(ArrayList<BatchJob> submittedJobs) {
		this.scheduler.setSubmittedJobs(submittedJobs);
	}
	
	public ArrayList<BatchJob> getSubmittedJobs() {
		return this.scheduler.getSubmittedJobs();
	}
	
	public ArrayList<BatchJob> getFinishedJobs() {
		return this.eventHandler.getFinishedJobs();
	}
	
	/**
	 * Retrieves all jobs that exist in the DC.
	 * @return List of all jobs that exist in the DC.
	 */
	public List<BatchJob> getJobs() {
		List<BatchJob> result = new ArrayList<BatchJob>();
		result.addAll(this.unsubmittedParsedJobs);
		result.addAll(this.scheduler.getSubmittedJobs());
		result.addAll(this.scheduler.getScheduledJobs());
		result.addAll(this.eventHandler.getRunningJobs());
		result.addAll(this.eventHandler.getPausedJobs());
		result.addAll(this.eventHandler.getFinishedJobs());
		
		return result;
	}
	
	public void setServerJobMapping(HashMap<Integer, String> newServerJobMapping) {
		this.eventHandler.setServerJobMapping(newServerJobMapping);
		
	}
	
	public ArrayList<Server> getOccupiedServer() {
		return this.eventHandler.getOccupiedServer();
	}
	
	public double getPue() {
		return pue;
	}

	public void setPue(double pue) {
		this.pue = pue;
	}
	
	public void setHistoricOverallPCOffset(int offset) {
		this.historicOverallECOffset = offset;
	}

	public List<Server> getServer() {
		return server;
	}

	public int getOverallCurrentPC() {
		return overallCurrentPC;
	}
	
	public double getCurrentJobPC() {
		return this.occupiedServerPC;
	}
	
	public double getCurrentHVACPC() {
		return this.currentHVACPower;
	}
	
	public double getCurrentITPC() {
		return this.currentITPower;
	}

	public HVAC getHvac() {
		return hvac;
	}

	public List<ESF> getUps() {
		return ups;
	}

	public void setId(int id) {
		this.id = id;
	}

	public int getId() {
		return id;
	}

	public void setChanged(boolean changed) {
		this.changed = changed;
	}

	public boolean isChanged() {
		return changed;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getName() {
		return name;
	}

	public void setSchedulingInterval(int schedulingInterval) {
		this.schedulingInterval = schedulingInterval;
	}
	
	public void setClock(int clock) {
		this.clock = clock;
	}
	
	public void setIsCopy(DC parent, int lastUnsubmittedJobRequest, int copiedIndexOffsetAtCreation) {
		this.isCopy = true;
		this.parent = parent;
		this.lastUnsubmittedJobRequestDate = lastUnsubmittedJobRequest;
		this.copiedIndexOffsetAtCreation = copiedIndexOffsetAtCreation;
	}
	
	public boolean isCopy() {
		return this.isCopy;
	}
	
	public DREventHandler getDREventHandler() {
		return this.drEventHandler;
	}
	
	public void setNextSchedulerCall(int nextSchedulerCall) {
		this.nextSchedulerCall = nextSchedulerCall;
	}
	
	public int getNextSchedulerCall() {
		return this.nextSchedulerCall;
	}
	
	public int getEndOfNextSchedulingInterval() {
		return this.nextSchedulerCall + this.schedulingInterval;
	}
	
	public void setHistoricalOverallEC(ArrayList<Double> historicOverallEC) {
		this.historicOverallPC = new ArrayList<Double>();
		
		for(double d : historicOverallEC) {
			this.historicOverallPC.add(d);
		}
	}
	
	/**
	 * Returns the current point in simulation time as a date in real time.
	 * @return Current point in simulation time as a date representation in real time.
	 */
	public Date getCurrentDate() {
		Date currentDate = this.simStartTime.getTime();
		currentDate.setTime(currentDate.getTime() + ((long) clock * (Setup.secondsPerSimulationTimestep*1000)));
		
		return currentDate;
	}
	
	public void setScheduler(Scheduler scheduler) {
		this.scheduler = scheduler;
		this.drEventHandler.setDCScheduler(scheduler);
	}
	
	public void setAllocator(EventHandler allocator) {
		this.eventHandler = allocator;
		this.finishedJobs = allocator.getFinishedJobs();
	}
	
	/**
	 * Schedules an event in the EventQueue.
	 * @param event Event that should be scheduled.
	 */
	public void scheduleEvent(Event event) {
		this.eventQueue.scheduleEvent(event);
	}
	
	/**
	 * Reschedules an event in the EventQueue of the DC.
	 * @param event Event that should be rescheduled.
	 * @param newTimestamp Point in simulation time to which the specified event should be rescheduled.
	 */
	public void rescheduleEvent(Event event, int newTimestamp) {
		this.eventQueue.rescheduleEvent(event, newTimestamp);
	}
	
	/**
	 * Removes an event from the EventQueue of the DC.
	 * @param event Event that should be removed.
	 */
	public void unscheduleEvent(Event event) {
		this.eventQueue.unscheduleEvent(event);
	}
	
	/**
	 * Removes an event from the scheduled event queue.
	 * @param event Event that should be removed from the scheduled events queue.
	 */
	public void handledEvent(Event event) {
		this.eventQueue.handledEvent(event);
	}
	
	/**
	 * Retrieves all cooling related events.
	 * @param timestamp Timestep for which all cooling events are requested.
	 * @return List of all cooling related events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getCoolingEvents(int timestamp) {
		List<Event> coolingEvents = new ArrayList<Event>(this.eventQueue.getEvents(EventType.DECREASE_COOLING_SETPOINT, timestamp));
		coolingEvents.addAll(this.eventQueue.getEvents(EventType.INCREASE_COOLING_SETPOINT, timestamp));
		return coolingEvents;
	}
	
	/**
	 * Retrieves all job start events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all job start events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getJobStartEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.JOB_START, timestamp);
	}
	
	/**
	 * Retrieves all job finish events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all job finish events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getJobFinishEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.JOB_FINISH, timestamp);
	}
	
	/**
	 * Retrieves all job pause events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all job pause events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getJobPauseEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.JOB_PAUSE, timestamp);
	}
	
	/**
	 * Retrieves all job restart events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all job restart events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getJobRestartEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.JOB_RESTART, timestamp);
	}
	
	/**
	 * Retrieves all job submission events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all job submission events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getJobSubmissionEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.JOB_SUBMISSION, timestamp);
	}
	
	/**
	 * Retrieves all DR request events that are scheduled at a specified point in simulation time.
	 * @param timestamp Point in simulation time for which the events are requested.
	 * @return A list of all DR request events that are scheduled at the specified point in simulation time.
	 */
	public List<Event> getDRRequestEvents(int timestamp) {
		return this.eventQueue.getEvents(EventType.DR_REQUEST, timestamp);
	}
	
	public void setLastCopiedIndex(int lastCopiedIndex) {
		this.lastCopiedIndex = lastCopiedIndex;
	}
	
	public int getLastCopiedIndex() {
		return this.lastCopiedIndex;
	}
	
	public Date getSimStartTime() {
		return this.simStartTime.getTime();
	}
	
	public int getClock() {
		return this.clock;
	}
	
	public double getOccupiedServerPC() {
		return this.occupiedServerPC;
	}
	
	public void setOccupiedServerPC(double occupiedServerEC) {
		this.occupiedServerPC = occupiedServerEC;
	}
	
	public double getOccupiedServerUtil() {
		return this.occupiedServerUtil;
	}
	
	public void setOccupiedServerUtil(double occupiedServerUtil) {
		this.occupiedServerUtil = occupiedServerUtil;
	}
	
	public void setSchedulingStrategy(DemandFlexibilitySchedulingStrategy strategy) {
		this.schedulingStrategy = strategy;
	}
	
	public double getSLACostOfCurrentTimestep() {
		return this.eventHandler.getCurrentSLACost();
	}
	
	public double getEnergyCostOfCurrentTimestep() {
		return this.currentEnergyCost;
	}
	
	/**
	 * Adds additional unsubmitted parsed jobs from the original DC instance to this instance.
	 * This method is only called on copied DC instances.
	 * @param newEndDate Submission date up to which the unsubmitted parsed jobs are copied.
	 */
	private void addAdditionalUnsubmittedJobs(int newEndDate) {
		for(BatchJob job : this.requestAdditionalUnsubmittedJobs(newEndDate, this.lastCopiedIndex, this.copiedIndexOffsetAtCreation)) {
			this.unsubmittedParsedJobs.add(job);
			this.eventQueue.scheduleEvent(new JobEvent(EventType.JOB_SUBMISSION, job.getSubmissionTime(), job));
			this.lastCopiedIndex++;
		}
		this.lastUnsubmittedJobRequestDate = newEndDate;
	}
	
	private ArrayList<BatchJob> requestAdditionalUnsubmittedJobs(int newEndDate, int lastCopiedIndex, int copiedIndexOffsetAtCreation) {
		if(this.isCopy) {
			return this.parent.requestAdditionalUnsubmittedJobs(newEndDate, lastCopiedIndex, copiedIndexOffsetAtCreation);
		}
		else {
			ArrayList<BatchJob> result = new ArrayList<BatchJob>();
			BatchJob job;
			int cIndex = (lastCopiedIndex - (this.copiedIndexOffset-copiedIndexOffsetAtCreation));
			if(cIndex < 0) {
				cIndex = -1;
			}
			for(int i= (cIndex+1); i < this.unsubmittedParsedJobs.size(); i++) {
				job = this.unsubmittedParsedJobs.get(i);
				if(job.getSubmissionTime() <= newEndDate) {
					result.add(job.deepCopy());
				}
				else {
					break;
				}
			}
			return result;
		}
	}
	
	private double calculateEnergyCosts(int intervalStart, int intervalEnd) {
		double energyCosts = 0;
		double energyPrice = 0;
		double usedEnergy = 0;
		for(int i = (intervalStart-this.historicOverallECOffset); i < ((intervalEnd-1)-this.historicOverallECOffset); i++) {
			energyPrice = EnergyPriceModelSelector.getEnergyPriceInCentPerKWh(i);
			usedEnergy = (this.historicOverallPC.get(i)/1000)/(3600/Setup.secondsPerSimulationTimestep);
			energyCosts += (energyPrice*usedEnergy);
		}
		return energyCosts;
	}
	
	private double calculateSLACosts(int intervalStart, int intervalEnd) {
		double slaCosts = 0;
		
		int actualFinish;
		for(BatchJob job : this.finishedJobs) {
			actualFinish = job.getActualFinishingTime();
			if(actualFinish >= intervalStart && actualFinish <= intervalEnd) {
				slaCosts += job.calculateSLACosts(Setup.usagePrice);
			}
		}
		return slaCosts;
	}

}
